-- Copyright (C) 2024 Eccelerators GmbH
-- 
-- This code was generated by:
--
-- HxS Compiler v0.0.0-0000000
-- VHDL Extension for HxS v0.0.0-0000000
-- 
-- Further information at https://eccelerators.com/hxs
-- 
-- Changes to this file may cause incorrect behavior and will be lost if the
-- code is regenerated.
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.PulseGeneratorPlainIfcPackage.all;

entity PulseGeneratorPlainBlk_PulseGeneratorPlainIfc is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Adr : in std_logic_vector(15 downto 0);
		Sel : in std_logic_vector(3 downto 0);
		DatIn : in std_logic_vector(31 downto 0);
		We : in std_logic;
		Stb : in std_logic;
		Cyc : in  std_logic;
		DatOut : out std_logic_vector(31 downto 0);
		Ack : out std_logic;
		Match : out std_logic;
		Operation : out std_logic;
		PulseWidthNs : out std_logic_vector(23 downto 0)
	);
end;

architecture Behavioural of PulseGeneratorPlainBlk_PulseGeneratorPlainIfc is

	signal ByteAddress : std_logic_vector(15 downto 0);
	signal PreReadData : std_logic_vector(31 downto 0);
	
	signal PreReadDataControlReg : std_logic_vector(24 downto 0);
	signal PreOrReadDataControlReg : std_logic_vector(31 downto 0);
	signal PreReadAckControlReg : std_logic;
	signal ReadDiffControlReg : std_logic;
	signal PreWriteAckControlReg : std_logic;
	signal WriteDiffControlReg : std_logic;
	signal WRegOperation : std_logic;
	signal WRegPulseWidthNs : std_logic_vector(23 downto 0);
	signal PreMatchReadControlReg : std_logic;
	signal PreMatchWriteControlReg : std_logic;

begin

	ByteAddress <= Adr(15 downto 2) & "00" when Sel(0) = '1' else
		Adr(15 downto 2) & "01" when Sel(1) = '1' else
		Adr(15 downto 2) & "10" when Sel(2) = '1' else
		Adr(15 downto 2) & "11" when Sel(3) = '1' else
		(others => '0');
	
	DatOut <= PreReadData;
	
	Match <= PreMatchReadControlReg or PreMatchWriteControlReg;
	
	Ack <= PreReadAckControlReg or PreWriteAckControlReg;
	
	PreOrReadDataControlReg <= "0000000" & PreReadDataControlReg
		when (PreMatchReadControlReg = '1' and PreReadAckControlReg = '1')
		else (others => '0');
	
	PreReadData <= PreOrReadDataControlReg;
	
	PreMatchReadControlRegProcess : process (ByteAddress, We, Stb, Cyc)
	begin
		if (unsigned(ByteAddress) >= unsigned(CONTROLREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(CONTROLREG_ADDRESS) + 3) then
			PreMatchReadControlReg <= not We and Stb and Cyc;
		else
			PreMatchReadControlReg <= '0';
		end if;
	end process;
	
	PreMatchWriteControlRegProcess : process (ByteAddress, We, Stb, Cyc)
	begin
		if (unsigned(ByteAddress) >= unsigned(CONTROLREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(CONTROLREG_ADDRESS) + 3) then
			PreMatchWriteControlReg <= We and Stb and Cyc;
		else
			PreMatchWriteControlReg <= '0';
		end if;
	end process;
	
	WriteDiffControlRegProcess : process (ByteAddress, We, Stb, Cyc, PreWriteAckControlReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(CONTROLREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(CONTROLREG_ADDRESS) + 3) then
			WriteDiffControlReg <= We and Stb and Cyc and not PreWriteAckControlReg;
		else
			WriteDiffControlReg <= '0';
		end if;
	end process;
	
	ReadDiffControlRegProcess : process (ByteAddress, We, Stb, Cyc, PreReadAckControlReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(CONTROLREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(CONTROLREG_ADDRESS) + 3) then
			ReadDiffControlReg <= not We and Stb and Cyc and not PreReadAckControlReg;
		else
			ReadDiffControlReg <= '0';
		end if;
	end process;
	
	SyncDomainControlReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckControlReg <= '0';
			PreWriteAckControlReg <= '0';
			WRegOperation <= OFF;
			WRegPulseWidthNs <= (others => '0');
		elsif rising_edge(Clk) then
			PreWriteAckControlReg <= WriteDiffControlReg;
			PreReadAckControlReg <= ReadDiffControlReg;
			if (WriteDiffControlReg = '1') then
				if (Sel(2) = '1') then WRegPulseWidthNs(23 downto 16) <= DatIn(23 downto 16); end if;
				if (Sel(1) = '1') then WRegPulseWidthNs(15 downto 8) <= DatIn(15 downto 8); end if;
				if (Sel(0) = '1') then WRegPulseWidthNs(7 downto 0) <= DatIn(7 downto 0); end if;
				if (Sel(3) = '1') then WRegOperation <= DatIn(24); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxControlReg : process (
		WRegOperation,
		WRegPulseWidthNs
	) begin
		PreReadDataControlReg <= (others => '0');
		PreReadDataControlReg(24) <= WRegOperation;
		PreReadDataControlReg(23 downto 0) <= WRegPulseWidthNs;
	end process;
	
	Operation <= WRegOperation;
	PulseWidthNs <= WRegPulseWidthNs;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity PulseGeneratorPlainIfcBusMonitor is
	generic (
		CLOCKS_UNTIL_CYCLE_TIMEOUT : integer := 1023
	);
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Cyc : in  std_logic;
		Match : in std_logic;
		UnoccupiedAck : out std_logic;
		TimeoutAck : out std_logic
	);
end;

architecture Behavioural of PulseGeneratorPlainIfcBusMonitor is

	function get_num_bits (arg : natural) return natural is
		variable nbits : natural;
		variable n : natural;
	begin
		n := arg;
		nbits := 1;
		while n > 1 loop
			nbits := nbits + 1;
			n := n / 2;
		end loop;
		return nbits;
	end function;
	
	constant TimeoutCounterWidth : integer := get_num_bits(CLOCKS_UNTIL_CYCLE_TIMEOUT);
	constant TimeoutCounterLeft : integer := TimeoutCounterWidth - 1;

	signal CycDelay : std_logic;
	signal PreUnoccupiedAck : std_logic;
	signal PreTimeoutAck : std_logic;
	signal TimeoutCounter : unsigned(TimeoutCounterLeft downto 0) := to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);

begin

	CycDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			CycDelay <= '0';
		elsif rising_edge(Clk) then
			CycDelay <= Cyc;
		end if;
	end process;

	MatchDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreUnoccupiedAck <= '0';
		elsif rising_edge(Clk) then
			PreUnoccupiedAck <= '0';
			if ((Cyc = '1') and (CycDelay = '1') and (Match = '0')) then
				PreUnoccupiedAck <= not PreUnoccupiedAck;
			end if;
		end if;
	end process;
	
	TimeoutDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreTimeoutAck <= '0';
			TimeoutCounter <= to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);
		elsif rising_edge(Clk) then
			PreTimeoutAck <= '0';
			TimeoutCounter <= to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);
			if ((Cyc = '1') and (CycDelay = '1') and (Match = '1')) then
				if (TimeoutCounter = 0) then
					PreTimeoutAck <= not PreTimeoutAck;
				else
					if (PreTimeoutAck = '0') then
						TimeoutCounter <= TimeoutCounter - 1;
					end if;
				end if;
			end if;
		end if;
	end process;

	UnoccupiedAck <= PreUnoccupiedAck;
	TimeoutAck <= PreTimeoutAck;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.PulseGeneratorPlainIfcPackage.all;

entity PulseGeneratorPlainIfcWishbone is
	generic (
		CLOCKS_UNTIL_CYCLE_TIMEOUT : integer := 1023
	);
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		WishboneDown : in T_PulseGeneratorPlainIfcWishboneDown;
		WishboneUp : out T_PulseGeneratorPlainIfcWishboneUp;
		Trace : out T_PulseGeneratorPlainIfcTrace;
		PulseGeneratorPlainBlkDown : out T_PulseGeneratorPlainIfcPulseGeneratorPlainBlkDown
	);
end;

architecture Behavioural of PulseGeneratorPlainIfcWishbone is

	signal BlockMatch : std_logic;
	signal UnoccupiedAck : std_logic;
	signal TimeoutAck : std_logic;
	
	signal PreWishboneUp : T_PulseGeneratorPlainIfcWishboneUp;
	
	signal PulseGeneratorPlainBlkDatOut : std_logic_vector(31 downto 0);
	signal PulseGeneratorPlainBlkAck : std_logic;
	signal PulseGeneratorPlainBlkMatch : std_logic;

begin

	i_PulseGeneratorPlainIfcBusMonitor : entity work.PulseGeneratorPlainIfcBusMonitor
		generic map (
			CLOCKS_UNTIL_CYCLE_TIMEOUT => CLOCKS_UNTIL_CYCLE_TIMEOUT
		)
		port map (
			Clk => Clk,
			Rst => Rst,
			Cyc => WishboneDown.Cyc,
			Match => BlockMatch,
			UnoccupiedAck => UnoccupiedAck,
			TimeoutAck => TimeoutAck
		);
	
	i_PulseGeneratorPlainBlk_PulseGeneratorPlainIfc : entity work.PulseGeneratorPlainBlk_PulseGeneratorPlainIfc
		port map (
			Clk => Clk,
			Rst => Rst,
			Adr => WishboneDown.Adr,
			Sel => WishboneDown.Sel,
			DatIn => WishboneDown.DatIn,
			We =>  WishboneDown.We,
			Stb => WishboneDown.Stb,
			Cyc => WishboneDown.Cyc,
			DatOut => PulseGeneratorPlainBlkDatOut,
			Ack => PulseGeneratorPlainBlkAck,
			Match => PulseGeneratorPlainBlkMatch,
			Operation => PulseGeneratorPlainBlkDown.Operation,
			PulseWidthNs => PulseGeneratorPlainBlkDown.PulseWidthNs
		);
	
	Trace.WishboneDown <= WishboneDown;
	Trace.WishboneUp <= PreWishboneUp;
	Trace.UnoccupiedAck <= UnoccupiedAck;
	Trace.TimeoutAck <= TimeoutAck;
	
	WishboneUp <= PreWishboneUp;
	
	PreWishboneUp.DatOut <= PulseGeneratorPlainBlkDatOut;
	
	PreWishboneUp.Ack <= PulseGeneratorPlainBlkAck
		or UnoccupiedAck 
		or TimeoutAck;
	
	BlockMatch <= PulseGeneratorPlainBlkMatch;

end;
