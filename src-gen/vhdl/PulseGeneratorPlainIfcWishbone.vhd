-- Copyright (C) 2025 Eccelerators GmbH
-- 
-- This code was generated by:
--
-- HxS Compiler 1.0.22-db393ac2
-- VHDL Extension for HxS 1.0.26-0b50ee5a
-- 
-- Further information at https://eccelerators.com/hxs
-- 
-- Changes to this file may cause incorrect behavior and will be lost if the
-- code is regenerated.
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.PulseGeneratorPlainIfcWishbonePackage.all;
use work.PulseGeneratorPlainIfcUserPackage.all;

entity PulseGeneratorPlainBlk_PulseGeneratorPlainIfcWishbone is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Adr : in std_logic_vector(15 downto 0);
		Sel : in std_logic_vector(3 downto 0);
		DatIn : in std_logic_vector(31 downto 0);
		We : in std_logic;
		Stb : in std_logic;
		Cyc : in  std_logic;
		DatOut : out std_logic_vector(31 downto 0);
		Ack : out std_logic;
		Match : out std_logic;
		Operation : out std_logic_vector(1 downto 0);
		PulsePeriodNs : out std_logic_vector(31 downto 0);
		PulseWidthNs : out std_logic_vector(31 downto 0)
	);
end;

architecture Behavioural of PulseGeneratorPlainBlk_PulseGeneratorPlainIfcWishbone is

	signal ByteAddress : std_logic_vector(15 downto 0);
	signal PreReadData : std_logic_vector(31 downto 0);
	
	signal PreReadDataControlReg : std_logic_vector(1 downto 0);
	signal PreOrReadDataControlReg : std_logic_vector(31 downto 0);
	signal PreReadAckControlReg : std_logic;
	signal ReadDiffControlReg : std_logic;
	signal PreWriteAckControlReg : std_logic;
	signal WriteDiffControlReg : std_logic;
	signal WRegOperation : std_logic_vector(1 downto 0);
	signal PreMatchReadControlReg : std_logic;
	signal PreMatchWriteControlReg : std_logic;
	
	signal PreReadDataPulsePeriodReg : std_logic_vector(31 downto 0);
	signal PreOrReadDataPulsePeriodReg : std_logic_vector(31 downto 0);
	signal PreReadAckPulsePeriodReg : std_logic;
	signal ReadDiffPulsePeriodReg : std_logic;
	signal PreWriteAckPulsePeriodReg : std_logic;
	signal WriteDiffPulsePeriodReg : std_logic;
	signal WRegPulsePeriodNs : std_logic_vector(31 downto 0);
	signal PreMatchReadPulsePeriodReg : std_logic;
	signal PreMatchWritePulsePeriodReg : std_logic;
	
	signal PreReadDataPulseWidthReg : std_logic_vector(31 downto 0);
	signal PreOrReadDataPulseWidthReg : std_logic_vector(31 downto 0);
	signal PreReadAckPulseWidthReg : std_logic;
	signal ReadDiffPulseWidthReg : std_logic;
	signal PreWriteAckPulseWidthReg : std_logic;
	signal WriteDiffPulseWidthReg : std_logic;
	signal WRegPulseWidthNs : std_logic_vector(31 downto 0);
	signal PreMatchReadPulseWidthReg : std_logic;
	signal PreMatchWritePulseWidthReg : std_logic;

begin

	ByteAddress <= Adr(15 downto 2) & "00" when Sel(0) = '1' else
		Adr(15 downto 2) & "01" when Sel(1) = '1' else
		Adr(15 downto 2) & "10" when Sel(2) = '1' else
		Adr(15 downto 2) & "11" when Sel(3) = '1' else
		(others => '0');
	
	DatOut <= PreReadData;
	
	Match <= PreMatchReadControlReg or PreMatchWriteControlReg
		  or PreMatchReadPulsePeriodReg or PreMatchWritePulsePeriodReg
		  or PreMatchReadPulseWidthReg or PreMatchWritePulseWidthReg;
	
	Ack <= PreReadAckControlReg or PreWriteAckControlReg
		or PreReadAckPulsePeriodReg or PreWriteAckPulsePeriodReg
		or PreReadAckPulseWidthReg or PreWriteAckPulseWidthReg;
	
	PreOrReadDataControlReg <= "000000000000000000000000000000" & PreReadDataControlReg
		when (PreMatchReadControlReg = '1' and PreReadAckControlReg = '1')
		else (others => '0');
	
	PreOrReadDataPulsePeriodReg <= PreReadDataPulsePeriodReg & x"00"
		when (PreMatchReadPulsePeriodReg = '1' and PreReadAckPulsePeriodReg = '1')
		else (others => '0');
	
	PreOrReadDataPulseWidthReg <= PreReadDataPulseWidthReg & x"00"
		when (PreMatchReadPulseWidthReg = '1' and PreReadAckPulseWidthReg = '1')
		else (others => '0');
	
	PreReadData <= PreOrReadDataControlReg
		or PreOrReadDataPulsePeriodReg
		or PreOrReadDataPulseWidthReg;
	
	PreMatchReadControlRegProcess : process (ByteAddress, We, Stb, Cyc)
	begin
		if (unsigned(ByteAddress) = unsigned(CONTROLREG_ADDRESS)) then
			PreMatchReadControlReg <= not We and Stb and Cyc;
		else
			PreMatchReadControlReg <= '0';
		end if;
	end process;
	
	PreMatchWriteControlRegProcess : process (ByteAddress, We, Stb, Cyc)
	begin
		if (unsigned(ByteAddress) = unsigned(CONTROLREG_ADDRESS)) then
			PreMatchWriteControlReg <= We and Stb and Cyc;
		else
			PreMatchWriteControlReg <= '0';
		end if;
	end process;
	
	WriteDiffControlRegProcess : process (ByteAddress, We, Stb, Cyc, PreWriteAckControlReg)
	begin
		if (unsigned(ByteAddress) = unsigned(CONTROLREG_ADDRESS)) then
			WriteDiffControlReg <= We and Stb and Cyc and not PreWriteAckControlReg;
		else
			WriteDiffControlReg <= '0';
		end if;
	end process;
	
	ReadDiffControlRegProcess : process (ByteAddress, We, Stb, Cyc, PreReadAckControlReg)
	begin
		if (unsigned(ByteAddress) = unsigned(CONTROLREG_ADDRESS)) then
			ReadDiffControlReg <= not We and Stb and Cyc and not PreReadAckControlReg;
		else
			ReadDiffControlReg <= '0';
		end if;
	end process;
	
	SyncDomainControlReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckControlReg <= '0';
			PreWriteAckControlReg <= '0';
			WRegOperation <= CLEARED;
		elsif rising_edge(Clk) then
			PreWriteAckControlReg <= WriteDiffControlReg;
			PreReadAckControlReg <= ReadDiffControlReg;
			if (WriteDiffControlReg = '1') then
				if (Sel(0) = '1') then WRegOperation(1 downto 0) <= DatIn(1 downto 0); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxControlReg : process (
		WRegOperation
	) begin
		PreReadDataControlReg <= (others => '0');
		PreReadDataControlReg(1 downto 0) <= WRegOperation;
	end process;
	
	Operation <= WRegOperation;
	
	PreMatchReadPulsePeriodRegProcess : process (ByteAddress, We, Stb, Cyc)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEPERIODREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEPERIODREG_ADDRESS) + 3) then
			PreMatchReadPulsePeriodReg <= not We and Stb and Cyc;
		else
			PreMatchReadPulsePeriodReg <= '0';
		end if;
	end process;
	
	PreMatchWritePulsePeriodRegProcess : process (ByteAddress, We, Stb, Cyc)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEPERIODREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEPERIODREG_ADDRESS) + 3) then
			PreMatchWritePulsePeriodReg <= We and Stb and Cyc;
		else
			PreMatchWritePulsePeriodReg <= '0';
		end if;
	end process;
	
	WriteDiffPulsePeriodRegProcess : process (ByteAddress, We, Stb, Cyc, PreWriteAckPulsePeriodReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEPERIODREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEPERIODREG_ADDRESS) + 3) then
			WriteDiffPulsePeriodReg <= We and Stb and Cyc and not PreWriteAckPulsePeriodReg;
		else
			WriteDiffPulsePeriodReg <= '0';
		end if;
	end process;
	
	ReadDiffPulsePeriodRegProcess : process (ByteAddress, We, Stb, Cyc, PreReadAckPulsePeriodReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEPERIODREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEPERIODREG_ADDRESS) + 3) then
			ReadDiffPulsePeriodReg <= not We and Stb and Cyc and not PreReadAckPulsePeriodReg;
		else
			ReadDiffPulsePeriodReg <= '0';
		end if;
	end process;
	
	SyncDomainPulsePeriodReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckPulsePeriodReg <= '0';
			PreWriteAckPulsePeriodReg <= '0';
			WRegPulsePeriodNs <= (others => '0');
		elsif rising_edge(Clk) then
			PreWriteAckPulsePeriodReg <= WriteDiffPulsePeriodReg;
			PreReadAckPulsePeriodReg <= ReadDiffPulsePeriodReg;
			if (WriteDiffPulsePeriodReg = '1') then
				if (Sel(3) = '1') then WRegPulsePeriodNs(23 downto 16) <= DatIn(31 downto 24); end if;
				if (Sel(2) = '1') then WRegPulsePeriodNs(15 downto 8) <= DatIn(23 downto 16); end if;
				if (Sel(1) = '1') then WRegPulsePeriodNs(7 downto 0) <= DatIn(15 downto 8); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxPulsePeriodReg : process (
		WRegPulsePeriodNs
	) begin
		PreReadDataPulsePeriodReg <= (others => '0');
		PreReadDataPulsePeriodReg(31 downto 0) <= WRegPulsePeriodNs;
	end process;
	
	PulsePeriodNs <= WRegPulsePeriodNs;
	
	PreMatchReadPulseWidthRegProcess : process (ByteAddress, We, Stb, Cyc)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEWIDTHREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEWIDTHREG_ADDRESS) + 3) then
			PreMatchReadPulseWidthReg <= not We and Stb and Cyc;
		else
			PreMatchReadPulseWidthReg <= '0';
		end if;
	end process;
	
	PreMatchWritePulseWidthRegProcess : process (ByteAddress, We, Stb, Cyc)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEWIDTHREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEWIDTHREG_ADDRESS) + 3) then
			PreMatchWritePulseWidthReg <= We and Stb and Cyc;
		else
			PreMatchWritePulseWidthReg <= '0';
		end if;
	end process;
	
	WriteDiffPulseWidthRegProcess : process (ByteAddress, We, Stb, Cyc, PreWriteAckPulseWidthReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEWIDTHREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEWIDTHREG_ADDRESS) + 3) then
			WriteDiffPulseWidthReg <= We and Stb and Cyc and not PreWriteAckPulseWidthReg;
		else
			WriteDiffPulseWidthReg <= '0';
		end if;
	end process;
	
	ReadDiffPulseWidthRegProcess : process (ByteAddress, We, Stb, Cyc, PreReadAckPulseWidthReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEWIDTHREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEWIDTHREG_ADDRESS) + 3) then
			ReadDiffPulseWidthReg <= not We and Stb and Cyc and not PreReadAckPulseWidthReg;
		else
			ReadDiffPulseWidthReg <= '0';
		end if;
	end process;
	
	SyncDomainPulseWidthReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckPulseWidthReg <= '0';
			PreWriteAckPulseWidthReg <= '0';
			WRegPulseWidthNs <= (others => '0');
		elsif rising_edge(Clk) then
			PreWriteAckPulseWidthReg <= WriteDiffPulseWidthReg;
			PreReadAckPulseWidthReg <= ReadDiffPulseWidthReg;
			if (WriteDiffPulseWidthReg = '1') then
				if (Sel(3) = '1') then WRegPulseWidthNs(23 downto 16) <= DatIn(31 downto 24); end if;
				if (Sel(2) = '1') then WRegPulseWidthNs(15 downto 8) <= DatIn(23 downto 16); end if;
				if (Sel(1) = '1') then WRegPulseWidthNs(7 downto 0) <= DatIn(15 downto 8); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxPulseWidthReg : process (
		WRegPulseWidthNs
	) begin
		PreReadDataPulseWidthReg <= (others => '0');
		PreReadDataPulseWidthReg(31 downto 0) <= WRegPulseWidthNs;
	end process;
	
	PulseWidthNs <= WRegPulseWidthNs;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity PulseGeneratorPlainIfcWishboneBusMonitor is
	generic (
		CLOCKS_UNTIL_CYCLE_TIMEOUT : integer := 1023
	);
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Cyc : in  std_logic;
		Match : in std_logic;
		UnoccupiedAck : out std_logic;
		TimeoutAck : out std_logic
	);
end;

architecture Behavioural of PulseGeneratorPlainIfcWishboneBusMonitor is

	function get_num_bits (arg : natural) return natural is
		variable nbits : natural;
		variable n : natural;
	begin
		n := arg;
		nbits := 1;
		while n > 1 loop
			nbits := nbits + 1;
			n := n / 2;
		end loop;
		return nbits;
	end function;
	
	constant TimeoutCounterWidth : integer := get_num_bits(CLOCKS_UNTIL_CYCLE_TIMEOUT);
	constant TimeoutCounterLeft : integer := TimeoutCounterWidth - 1;

	signal CycDelay : std_logic;
	signal PreUnoccupiedAck : std_logic;
	signal PreTimeoutAck : std_logic;
	signal TimeoutCounter : unsigned(TimeoutCounterLeft downto 0) := to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);

begin

	CycDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			CycDelay <= '0';
		elsif rising_edge(Clk) then
			CycDelay <= Cyc;
		end if;
	end process;

	MatchDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreUnoccupiedAck <= '0';
		elsif rising_edge(Clk) then
			PreUnoccupiedAck <= '0';
			if ((Cyc = '1') and (CycDelay = '1') and (Match = '0')) then
				PreUnoccupiedAck <= not PreUnoccupiedAck;
			end if;
		end if;
	end process;
	
	TimeoutDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreTimeoutAck <= '0';
			TimeoutCounter <= to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);
		elsif rising_edge(Clk) then
			PreTimeoutAck <= '0';
			TimeoutCounter <= to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);
			if ((Cyc = '1') and (CycDelay = '1') and (Match = '1')) then
				if (TimeoutCounter = 0) then
					PreTimeoutAck <= not PreTimeoutAck;
				else
					if (PreTimeoutAck = '0') then
						TimeoutCounter <= TimeoutCounter - 1;
					end if;
				end if;
			end if;
		end if;
	end process;

	UnoccupiedAck <= PreUnoccupiedAck;
	TimeoutAck <= PreTimeoutAck;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.PulseGeneratorPlainIfcWishbonePackage.all;
use work.PulseGeneratorPlainIfcUserPackage.all;

entity PulseGeneratorPlainIfcWishbone is
	generic (
		CLOCKS_UNTIL_CYCLE_TIMEOUT : integer := 1023
	);
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		WishboneDown : in T_PulseGeneratorPlainIfcWishboneDown;
		WishboneUp : out T_PulseGeneratorPlainIfcWishboneUp;
		Trace : out T_PulseGeneratorPlainIfcWishboneTrace;
		PulseGeneratorPlainBlkDown : out T_PulseGeneratorPlainIfcPulseGeneratorPlainBlkDown
	);
end;

architecture Behavioural of PulseGeneratorPlainIfcWishbone is

	signal BlockMatch : std_logic;
	signal UnoccupiedAck : std_logic;
	signal TimeoutAck : std_logic;
	
	signal PreWishboneUp : T_PulseGeneratorPlainIfcWishboneUp;
	
	signal PulseGeneratorPlainBlkDatOut : std_logic_vector(31 downto 0);
	signal PulseGeneratorPlainBlkAck : std_logic;
	signal PulseGeneratorPlainBlkMatch : std_logic;

begin

	i_PulseGeneratorPlainIfcWishboneBusMonitor : entity work.PulseGeneratorPlainIfcWishboneBusMonitor
		generic map (
			CLOCKS_UNTIL_CYCLE_TIMEOUT => CLOCKS_UNTIL_CYCLE_TIMEOUT
		)
		port map (
			Clk => Clk,
			Rst => Rst,
			Cyc => WishboneDown.Cyc,
			Match => BlockMatch,
			UnoccupiedAck => UnoccupiedAck,
			TimeoutAck => TimeoutAck
		);
	
	i_PulseGeneratorPlainBlk_PulseGeneratorPlainIfcWishbone : entity work.PulseGeneratorPlainBlk_PulseGeneratorPlainIfcWishbone
		port map (
			Clk => Clk,
			Rst => Rst,
			Adr => WishboneDown.Adr,
			Sel => WishboneDown.Sel,
			DatIn => WishboneDown.DatIn,
			We =>  WishboneDown.We,
			Stb => WishboneDown.Stb,
			Cyc => WishboneDown.Cyc,
			DatOut => PulseGeneratorPlainBlkDatOut,
			Ack => PulseGeneratorPlainBlkAck,
			Match => PulseGeneratorPlainBlkMatch,
			Operation => PulseGeneratorPlainBlkDown.Operation,
			PulsePeriodNs => PulseGeneratorPlainBlkDown.PulsePeriodNs,
			PulseWidthNs => PulseGeneratorPlainBlkDown.PulseWidthNs
		);
	
	Trace.WishboneDown <= WishboneDown;
	Trace.WishboneUp <= PreWishboneUp;
	Trace.UnoccupiedAck <= UnoccupiedAck;
	Trace.TimeoutAck <= TimeoutAck;
	
	WishboneUp <= PreWishboneUp;
	
	PreWishboneUp.DatOut <= PulseGeneratorPlainBlkDatOut;
	
	PreWishboneUp.Ack <= PulseGeneratorPlainBlkAck
		or UnoccupiedAck 
		or TimeoutAck;
	
	BlockMatch <= PulseGeneratorPlainBlkMatch;

end;
