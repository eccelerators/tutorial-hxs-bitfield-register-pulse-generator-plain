-- Copyright (C) 2024 Eccelerators GmbH
-- 
-- This code was generated by:
--
-- HxS Compiler v0.0.0-0000000
-- VHDL Extension for HxS 1.0.21-b962bd24
-- 
-- Further information at https://eccelerators.com/hxs
-- 
-- Changes to this file may cause incorrect behavior and will be lost if the
-- code is regenerated.
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.TutBitfieldRegisterIfcPackage.all;

entity TutBlk_TutBitfieldRegisterIfc is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Adr : in std_logic_vector(7 downto 0);
		Sel : in std_logic_vector(3 downto 0);
		DatIn : in std_logic_vector(31 downto 0);
		We : in std_logic;
		Stb : in std_logic;
		Cyc : in  std_logic;
		DatOut : out std_logic_vector(31 downto 0);
		Ack : out std_logic;
		Match : out std_logic;
		CounterOperation : out std_logic_vector(1 downto 0);
		CounterThreshold : out std_logic_vector(15 downto 0)
	);
end;

architecture Behavioural of TutBlk_TutBitfieldRegisterIfc is

	signal PreDatOut : std_logic_vector(31 downto 0);
	
	signal PreDatOutTutReg : std_logic_vector(17 downto 0);
	signal PreReadAckTutReg : std_logic;
	signal ReadDiffTutReg : std_logic;
	signal PreWriteAckTutReg : std_logic;
	signal WriteDiffTutReg : std_logic;
	signal WRegCounterOperation : std_logic_vector(1 downto 0);
	signal WRegCounterThreshold : std_logic_vector(15 downto 0);
	signal PreMatchReadTutReg : std_logic;
	signal PreMatchWriteTutReg : std_logic;

begin

	DatOut <= PreDatOut;
	
	Match <= PreMatchReadTutReg or PreMatchWriteTutReg;
	
	Ack <= PreReadAckTutReg or PreWriteAckTutReg;
	
	PreDatOutMux: process (
		PreDatOutTutReg,
		PreMatchReadTutReg,
		PreReadAckTutReg
	) begin
		PreDatOut <= (others => '0');
		if (PreMatchReadTutReg = '1' and PreReadAckTutReg = '1') then
			PreDatOut <= std_logic_vector(resize(unsigned(PreDatOutTutReg), PreDatOut'LENGTH));
		end if;
	end process;
	
	PreMatchReadTutRegProcess : process (Adr, We, Stb, Cyc)
	begin
		if ((unsigned(Adr)/4)*4 = unsigned(TUTREG_ADDRESS)) then
			PreMatchReadTutReg <= not We and Stb and Cyc;
		else
			PreMatchReadTutReg <= '0';
		end if;
	end process;
	
	PreMatchWriteTutRegProcess : process (Adr, We, Stb, Cyc)
	begin
		if ((unsigned(Adr)/4)*4 = unsigned(TUTREG_ADDRESS)) then
			PreMatchWriteTutReg <= We and Stb and Cyc;
		else
			PreMatchWriteTutReg <= '0';
		end if;
	end process;
	
	WriteDiffTutRegProcess : process (Adr, We, Stb, Cyc, PreWriteAckTutReg)
	begin
		if ((unsigned(Adr)/4)*4 = unsigned(TUTREG_ADDRESS)) then
			WriteDiffTutReg <=  We and Stb and Cyc and not PreWriteAckTutReg;
		else
			WriteDiffTutReg <= '0';
		end if;
	end process;
	
	ReadDiffTutRegProcess : process (Adr, We, Stb, Cyc, PreReadAckTutReg)
	begin
		if ((unsigned(Adr)/4)*4 = unsigned(TUTREG_ADDRESS)) then
			ReadDiffTutReg <= not We and Stb and Cyc and not PreReadAckTutReg;
		else
			ReadDiffTutReg <= '0';
		end if;
	end process;
	
	SyncPartTutReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckTutReg <= '0';
			PreWriteAckTutReg <= '0';
			WRegCounterOperation <= HALTED;
			WRegCounterThreshold <= (others => '0');
		elsif rising_edge(Clk) then
			PreWriteAckTutReg <= WriteDiffTutReg;
			PreReadAckTutReg <= ReadDiffTutReg;
			if (WriteDiffTutReg = '1') then
				if (Sel(1) = '1') then WRegCounterThreshold(15 downto 8) <= DatIn(15 downto 8); end if;
				if (Sel(0) = '1') then WRegCounterThreshold(7 downto 0) <= DatIn(7 downto 0); end if;
				if (Sel(2) = '1') then WRegCounterOperation(1 downto 0) <= DatIn(17 downto 16); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxForTutReg : process (
		WRegCounterOperation,
		WRegCounterThreshold
	) begin
		PreDatOutTutReg <= (others => '0');
		PreDatOutTutReg(17 downto 16) <= WRegCounterOperation;
		PreDatOutTutReg(15 downto 0) <= WRegCounterThreshold;
	end process;
	
	CounterOperation <= WRegCounterOperation;
	CounterThreshold <= WRegCounterThreshold;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity TutBitfieldRegisterIfcBusMonitor is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Cyc : in  std_logic;
		Match : in std_logic;
		UnoccupiedAck : out std_logic;
		TimeoutAck : out std_logic
	);
end;

architecture Behavioural of TutBitfieldRegisterIfcBusMonitor is

	signal CycDelay : std_logic;
	signal PreUnoccupiedAck : std_logic;
	signal PreTimeoutAck : std_logic;
	signal TimeoutCounter : unsigned(9 downto 0);

begin

	CycDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			CycDelay <= '0';
		elsif rising_edge(Clk) then
			CycDelay <= Cyc;
		end if;
	end process;

	MatchDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreUnoccupiedAck <= '0';
		elsif rising_edge(Clk) then
			PreUnoccupiedAck <= '0';
			if ((Cyc = '1') and (CycDelay = '1') and (Match = '0')) then
				PreUnoccupiedAck <= not PreUnoccupiedAck;
			end if;
		end if;
	end process;
	
	TimeoutDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreTimeoutAck <= '0';
			TimeoutCounter <= (others => '1');
		elsif rising_edge(Clk) then
			PreTimeoutAck <= '0';
			TimeoutCounter <= (others => '1');
			if ((Cyc = '1') and (CycDelay = '1') and (Match = '1')) then
				if (TimeoutCounter = 0) then
					PreTimeoutAck <= not PreTimeoutAck;
				else
					TimeoutCounter <= TimeoutCounter - 1;
				end if;
			end if;
		end if;
	end process;

	UnoccupiedAck <= PreUnoccupiedAck;
	TimeoutAck <= PreTimeoutAck;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.TutBitfieldRegisterIfcPackage.all;

entity TutBitfieldRegisterIfcWishbone is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		WishboneDown : in T_TutBitfieldRegisterIfcWishboneDown;
		WishboneUp : out T_TutBitfieldRegisterIfcWishboneUp;
		Trace : out T_TutBitfieldRegisterIfcTrace;
		TutBlkDown : out T_TutBitfieldRegisterIfcTutBlkDown
	);
end;

architecture Behavioural of TutBitfieldRegisterIfcWishbone is

	signal BlockMatch : std_logic;
	signal UnoccupiedAck : std_logic;
	signal TimeoutAck : std_logic;
	
	signal PreWishboneUp : T_TutBitfieldRegisterIfcWishboneUp;
	
	signal TutBlkDatOut : std_logic_vector(31 downto 0);
	signal TutBlkAck : std_logic;
	signal TutBlkMatch : std_logic;

begin

	i_TutBitfieldRegisterIfcBusMonitor : entity work.TutBitfieldRegisterIfcBusMonitor
		port map (
			Clk => Clk,
			Rst => Rst,
			Cyc => WishboneDown.Cyc,
			Match => BlockMatch,
			UnoccupiedAck => UnoccupiedAck,
			TimeoutAck => TimeoutAck
		);
	
	i_TutBlk_TutBitfieldRegisterIfc : entity work.TutBlk_TutBitfieldRegisterIfc
		port map (
			Clk => Clk,
			Rst => Rst,
			Adr => WishboneDown.Adr,
			Sel => WishboneDown.Sel,
			DatIn => WishboneDown.DatIn,
			We =>  WishboneDown.We,
			Stb => WishboneDown.Stb,
			Cyc => WishboneDown.Cyc,
			DatOut => TutBlkDatOut,
			Ack => TutBlkAck,
			Match => TutBlkMatch,
			CounterOperation => TutBlkDown.CounterOperation,
			CounterThreshold => TutBlkDown.CounterThreshold
		);
	
	Trace.WishboneDown <= WishboneDown;
	Trace.WishboneUp <= PreWishboneUp;
	Trace.UnoccupiedAck <= UnoccupiedAck;
	Trace.TimeoutAck <= TimeoutAck;
	
	WishboneUp <= PreWishboneUp;
	
	PreWishboneUp.DatOut <= TutBlkDatOut;
	
	PreWishboneUp.Ack <= TutBlkAck
		or UnoccupiedAck 
		or TimeoutAck;
	
	BlockMatch <= TutBlkMatch;

end;
