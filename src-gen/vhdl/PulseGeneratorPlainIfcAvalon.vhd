-- Copyright (C) 2024 Eccelerators GmbH
-- 
-- This code was generated by:
--
-- HxS Compiler v0.0.0-0000000
-- VHDL Extension for HxS v0.0.0-0000000
-- 
-- Further information at https://eccelerators.com/hxs
-- 
-- Changes to this file may cause incorrect behavior and will be lost if the
-- code is regenerated.
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.PulseGeneratorPlainIfcPackage.all;

entity PulseGeneratorPlainBlk_PulseGeneratorPlainIfc is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Address : in std_logic_vector(15 downto 0);
		ByteEnable : in std_logic_vector(3 downto 0);
		Read : in std_logic;
		ReadData : out std_logic_vector(31 downto 0);
		Write : in std_logic;
		WriteData : in std_logic_vector(31 downto 0);
		WaitRequest : out std_logic;
		Match : out std_logic;
		Operation : out std_logic_vector(1 downto 0);
		PulseWidthNs : out std_logic_vector(23 downto 0);
		PulsePeriodNs : out std_logic_vector(23 downto 0)
	);
end;

architecture Behavioural of PulseGeneratorPlainBlk_PulseGeneratorPlainIfc is

	signal ByteAddress : std_logic_vector(15 downto 0);
	signal PreReadData : std_logic_vector(31 downto 0);
	
	signal PreReadDataControlReg : std_logic_vector(25 downto 0);
	signal PreOrReadDataControlReg : std_logic_vector(31 downto 0);
	signal PreReadAckControlReg : std_logic;
	signal ReadDiffControlReg : std_logic;
	signal PreWriteAckControlReg : std_logic;
	signal WriteDiffControlReg : std_logic;
	signal WRegOperation : std_logic_vector(1 downto 0);
	signal WRegPulseWidthNs : std_logic_vector(23 downto 0);
	signal PreMatchReadControlReg : std_logic;
	signal PreMatchWriteControlReg : std_logic;
	
	signal PreReadDataParameterReg : std_logic_vector(23 downto 0);
	signal PreOrReadDataParameterReg : std_logic_vector(31 downto 0);
	signal PreReadAckParameterReg : std_logic;
	signal ReadDiffParameterReg : std_logic;
	signal PreWriteAckParameterReg : std_logic;
	signal WriteDiffParameterReg : std_logic;
	signal WRegPulsePeriodNs : std_logic_vector(23 downto 0);
	signal PreMatchReadParameterReg : std_logic;
	signal PreMatchWriteParameterReg : std_logic;

begin

	ByteAddress <= Address(15 downto 2) & "00" when ByteEnable(0) = '1' else
		Address(15 downto 2) & "01" when ByteEnable(1) = '1' else
		Address(15 downto 2) & "10" when ByteEnable(2) = '1' else
		Address(15 downto 2) & "11" when ByteEnable(3) = '1' else
		(others => '0');
	
	ReadData <= PreReadData;
	
	Match <= PreMatchReadControlReg or PreMatchWriteControlReg
		  or PreMatchReadParameterReg or PreMatchWriteParameterReg;
	
	WaitRequest <= not (PreReadAckControlReg or PreWriteAckControlReg
		or PreReadAckParameterReg or PreWriteAckParameterReg);
	
	PreOrReadDataControlReg <= "000000" & PreReadDataControlReg
		when (PreMatchReadControlReg = '1' and PreReadAckControlReg = '1')
		else (others => '0');
	
	PreOrReadDataParameterReg <= x"00" & PreReadDataParameterReg
		when (PreMatchReadParameterReg = '1' and PreReadAckParameterReg = '1')
		else (others => '0');
	
	PreReadData <= PreOrReadDataControlReg
		or PreOrReadDataParameterReg;
	
	PreMatchReadControlRegProcess : process (ByteAddress, Read)
	begin
		if (unsigned(ByteAddress) >= unsigned(CONTROLREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(CONTROLREG_ADDRESS) + 3) then
			PreMatchReadControlReg <= Read;
		else
			PreMatchReadControlReg <= '0';
		end if;
	end process;
	
	PreMatchWriteControlRegProcess : process (ByteAddress, Write)
	begin
		if (unsigned(ByteAddress) >= unsigned(CONTROLREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(CONTROLREG_ADDRESS) + 3) then
			PreMatchWriteControlReg <= Write;
		else
			PreMatchWriteControlReg <= '0';
		end if;
	end process;
	WriteDiffControlRegProcess : process (ByteAddress, Write, PreWriteAckControlReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(CONTROLREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(CONTROLREG_ADDRESS) + 3) then
			WriteDiffControlReg <= Write and not PreWriteAckControlReg;
		else
			WriteDiffControlReg <= '0';
		end if;
	end process;
	
	ReadDiffControlRegProcess : process (ByteAddress, Read, PreReadAckControlReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(CONTROLREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(CONTROLREG_ADDRESS) + 3) then
			ReadDiffControlReg <= Read and not PreReadAckControlReg;
		else
			ReadDiffControlReg <= '0';
		end if;
	end process;
	
	SyncDomainControlReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckControlReg <= '0';
			PreWriteAckControlReg <= '0';
			WRegOperation <= CLEARED;
			WRegPulseWidthNs <= (others => '0');
		elsif rising_edge(Clk) then
			PreWriteAckControlReg <= WriteDiffControlReg;
			PreReadAckControlReg <= ReadDiffControlReg;
			if (WriteDiffControlReg = '1') then
				if (ByteEnable(2) = '1') then WRegPulseWidthNs(23 downto 16) <= WriteData(23 downto 16); end if;
				if (ByteEnable(1) = '1') then WRegPulseWidthNs(15 downto 8) <= WriteData(15 downto 8); end if;
				if (ByteEnable(0) = '1') then WRegPulseWidthNs(7 downto 0) <= WriteData(7 downto 0); end if;
				if (ByteEnable(3) = '1') then WRegOperation(1 downto 0) <= WriteData(25 downto 24); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxControlReg : process (
		WRegOperation,
		WRegPulseWidthNs
	) begin
		PreReadDataControlReg <= (others => '0');
		PreReadDataControlReg(25 downto 24) <= WRegOperation;
		PreReadDataControlReg(23 downto 0) <= WRegPulseWidthNs;
	end process;
	
	Operation <= WRegOperation;
	PulseWidthNs <= WRegPulseWidthNs;
	
	PreMatchReadParameterRegProcess : process (ByteAddress, Read)
	begin
		if (unsigned(ByteAddress) >= unsigned(PARAMETERREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PARAMETERREG_ADDRESS) + 2) then
			PreMatchReadParameterReg <= Read;
		else
			PreMatchReadParameterReg <= '0';
		end if;
	end process;
	
	PreMatchWriteParameterRegProcess : process (ByteAddress, Write)
	begin
		if (unsigned(ByteAddress) >= unsigned(PARAMETERREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PARAMETERREG_ADDRESS) + 2) then
			PreMatchWriteParameterReg <= Write;
		else
			PreMatchWriteParameterReg <= '0';
		end if;
	end process;
	WriteDiffParameterRegProcess : process (ByteAddress, Write, PreWriteAckParameterReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(PARAMETERREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PARAMETERREG_ADDRESS) + 2) then
			WriteDiffParameterReg <= Write and not PreWriteAckParameterReg;
		else
			WriteDiffParameterReg <= '0';
		end if;
	end process;
	
	ReadDiffParameterRegProcess : process (ByteAddress, Read, PreReadAckParameterReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(PARAMETERREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PARAMETERREG_ADDRESS) + 2) then
			ReadDiffParameterReg <= Read and not PreReadAckParameterReg;
		else
			ReadDiffParameterReg <= '0';
		end if;
	end process;
	
	SyncDomainParameterReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckParameterReg <= '0';
			PreWriteAckParameterReg <= '0';
			WRegPulsePeriodNs <= (others => '0');
		elsif rising_edge(Clk) then
			PreWriteAckParameterReg <= WriteDiffParameterReg;
			PreReadAckParameterReg <= ReadDiffParameterReg;
			if (WriteDiffParameterReg = '1') then
				if (ByteEnable(2) = '1') then WRegPulsePeriodNs(23 downto 16) <= WriteData(23 downto 16); end if;
				if (ByteEnable(1) = '1') then WRegPulsePeriodNs(15 downto 8) <= WriteData(15 downto 8); end if;
				if (ByteEnable(0) = '1') then WRegPulsePeriodNs(7 downto 0) <= WriteData(7 downto 0); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxParameterReg : process (
		WRegPulsePeriodNs
	) begin
		PreReadDataParameterReg <= (others => '0');
		PreReadDataParameterReg(23 downto 0) <= WRegPulsePeriodNs;
	end process;
	
	PulsePeriodNs <= WRegPulsePeriodNs;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity PulseGeneratorPlainIfcBusMonitor is
	generic (
		CLOCKS_UNTIL_CYCLE_TIMEOUT : integer := 1023
	);
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Read : in  std_logic;
		Write : in  std_logic;
		Match : in std_logic;
		UnoccupiedAck : out std_logic;
		TimeoutAck : out std_logic
	);
end;

architecture Behavioural of PulseGeneratorPlainIfcBusMonitor is

	function get_num_bits (arg : natural) return natural is
		variable nbits : natural;
		variable n : natural;
	begin
		n := arg;
		nbits := 1;
		while n > 1 loop
			nbits := nbits + 1;
			n := n / 2;
		end loop;
		return nbits;
	end function;

	constant TimeoutCounterWidth : integer := get_num_bits(CLOCKS_UNTIL_CYCLE_TIMEOUT);
	constant TimeoutCounterLeft : integer := TimeoutCounterWidth - 1;

	signal BusAccessDelay : std_logic;
	signal BusAccess : std_logic;
	signal PreUnoccupiedAck : std_logic;
	signal PreTimeoutAck : std_logic;
	signal TimeoutCounter : unsigned(TimeoutCounterLeft downto 0) := to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);

begin

	BusAccess <= Read or Write;

	BusAccessDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			BusAccessDelay <= '0';
		elsif rising_edge(Clk) then
			BusAccessDelay <= BusAccess;
		end if;
	end process;

	MatchDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreUnoccupiedAck <= '0';
		elsif rising_edge(Clk) then
			PreUnoccupiedAck <= '0';
			if ((BusAccess = '1') and (BusAccessDelay = '1') and (Match = '0')) then
				PreUnoccupiedAck <= not PreUnoccupiedAck;
			end if;
		end if;
	end process;
	
	TimeoutDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreTimeoutAck <= '0';
			TimeoutCounter <= to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);
		elsif rising_edge(Clk) then
			PreTimeoutAck <= '0';
			TimeoutCounter <= to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);
			if ((BusAccess = '1') and (BusAccessDelay = '1') and (Match = '1')) then
				if (TimeoutCounter = 0) then
					PreTimeoutAck <= not PreTimeoutAck;
				else
					if (PreTimeoutAck = '0') then
						TimeoutCounter <= TimeoutCounter - 1;
					end if;
				end if;
			end if;
		end if;
	end process;

	UnoccupiedAck <= PreUnoccupiedAck;
	TimeoutAck <= PreTimeoutAck;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.PulseGeneratorPlainIfcPackage.all;

entity PulseGeneratorPlainIfcAvalon is
	generic (
		CLOCKS_UNTIL_CYCLE_TIMEOUT : integer := 1023
	);
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		AvalonDown : in T_PulseGeneratorPlainIfcAvalonDown;
		AvalonUp : out T_PulseGeneratorPlainIfcAvalonUp;
		Trace : out T_PulseGeneratorPlainIfcAvalonTrace;
		PulseGeneratorPlainBlkDown : out T_PulseGeneratorPlainIfcPulseGeneratorPlainBlkDown
	);
end;

architecture Behavioural of PulseGeneratorPlainIfcAvalon is

	signal BlockMatch : std_logic;
	signal UnoccupiedAck : std_logic;
	signal TimeoutAck : std_logic;
	
	signal PreAvalonUp : T_PulseGeneratorPlainIfcAvalonUp;
	
	signal PulseGeneratorPlainBlkReadData : std_logic_vector(31 downto 0);
	signal PulseGeneratorPlainBlkWaitRequest : std_logic;
	signal PulseGeneratorPlainBlkMatch : std_logic;

begin

	i_PulseGeneratorPlainIfcBusMonitor : entity work.PulseGeneratorPlainIfcBusMonitor
		generic map (
			CLOCKS_UNTIL_CYCLE_TIMEOUT => CLOCKS_UNTIL_CYCLE_TIMEOUT
		)
		port map (
			Clk => Clk,
			Rst => Rst,
			Read => AvalonDown.Read,
			Write => AvalonDown.Write,
			Match => BlockMatch,
			UnoccupiedAck => UnoccupiedAck,
			TimeoutAck => TimeoutAck
		);
	
	i_PulseGeneratorPlainBlk_PulseGeneratorPlainIfc : entity work.PulseGeneratorPlainBlk_PulseGeneratorPlainIfc
		port map (
			Clk => Clk,
			Rst => Rst,
			Address => AvalonDown.Address,
			ByteEnable => AvalonDown.ByteEnable,
			Read => AvalonDown.Read,
			ReadData =>  PulseGeneratorPlainBlkReadData,
			Write => AvalonDown.Write,
			WriteData => AvalonDown.WriteData,
			WaitRequest => PulseGeneratorPlainBlkWaitRequest,
			Match => PulseGeneratorPlainBlkMatch,
			Operation => PulseGeneratorPlainBlkDown.Operation,
			PulseWidthNs => PulseGeneratorPlainBlkDown.PulseWidthNs,
			PulsePeriodNs => PulseGeneratorPlainBlkDown.PulsePeriodNs
		);
	
	Trace.AvalonDown <= AvalonDown;
	Trace.AvalonUp <= PreAvalonUp;
	Trace.UnoccupiedAck <= UnoccupiedAck;
	Trace.TimeoutAck <= TimeoutAck;
	
	AvalonUp <= PreAvalonUp;
	
	PreAvalonUp.ReadData <= PulseGeneratorPlainBlkReadData;
	
	PreAvalonUp.WaitRequest <= PulseGeneratorPlainBlkWaitRequest
		and not UnoccupiedAck
		and not TimeoutAck;
	
	BlockMatch <= PulseGeneratorPlainBlkMatch;

end;
