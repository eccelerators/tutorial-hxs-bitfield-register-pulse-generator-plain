-- Copyright (C) 2025 Eccelerators GmbH
-- 
-- This code was generated by:
--
-- HxS Compiler 1.0.22-db393ac2
-- VHDL Extension for HxS 1.0.26-0b50ee5a
-- 
-- Further information at https://eccelerators.com/hxs
-- 
-- Changes to this file may cause incorrect behavior and will be lost if the
-- code is regenerated.
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.PulseGeneratorPlainIfcAvalonPackage.all;
use work.PulseGeneratorPlainIfcUserPackage.all;

entity PulseGeneratorPlainBlk_PulseGeneratorPlainIfcAvalon is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Address : in std_logic_vector(15 downto 0);
		ByteEnable : in std_logic_vector(3 downto 0);
		Read : in std_logic;
		ReadData : out std_logic_vector(31 downto 0);
		Write : in std_logic;
		WriteData : in std_logic_vector(31 downto 0);
		WaitRequest : out std_logic;
		Match : out std_logic;
		Operation : out std_logic_vector(1 downto 0);
		PulsePeriodNs : out std_logic_vector(31 downto 0);
		PulseWidthNs : out std_logic_vector(31 downto 0)
	);
end;

architecture Behavioural of PulseGeneratorPlainBlk_PulseGeneratorPlainIfcAvalon is

	signal ByteAddress : std_logic_vector(15 downto 0);
	signal PreReadData : std_logic_vector(31 downto 0);
	
	signal PreReadDataControlReg : std_logic_vector(1 downto 0);
	signal PreOrReadDataControlReg : std_logic_vector(31 downto 0);
	signal PreReadAckControlReg : std_logic;
	signal ReadDiffControlReg : std_logic;
	signal PreWriteAckControlReg : std_logic;
	signal WriteDiffControlReg : std_logic;
	signal WRegOperation : std_logic_vector(1 downto 0);
	signal PreMatchReadControlReg : std_logic;
	signal PreMatchWriteControlReg : std_logic;
	
	signal PreReadDataPulsePeriodReg : std_logic_vector(31 downto 0);
	signal PreOrReadDataPulsePeriodReg : std_logic_vector(31 downto 0);
	signal PreReadAckPulsePeriodReg : std_logic;
	signal ReadDiffPulsePeriodReg : std_logic;
	signal PreWriteAckPulsePeriodReg : std_logic;
	signal WriteDiffPulsePeriodReg : std_logic;
	signal WRegPulsePeriodNs : std_logic_vector(31 downto 0);
	signal PreMatchReadPulsePeriodReg : std_logic;
	signal PreMatchWritePulsePeriodReg : std_logic;
	
	signal PreReadDataPulseWidthReg : std_logic_vector(31 downto 0);
	signal PreOrReadDataPulseWidthReg : std_logic_vector(31 downto 0);
	signal PreReadAckPulseWidthReg : std_logic;
	signal ReadDiffPulseWidthReg : std_logic;
	signal PreWriteAckPulseWidthReg : std_logic;
	signal WriteDiffPulseWidthReg : std_logic;
	signal WRegPulseWidthNs : std_logic_vector(31 downto 0);
	signal PreMatchReadPulseWidthReg : std_logic;
	signal PreMatchWritePulseWidthReg : std_logic;

begin

	ByteAddress <= Address(15 downto 2) & "00" when ByteEnable(0) = '1' else
		Address(15 downto 2) & "01" when ByteEnable(1) = '1' else
		Address(15 downto 2) & "10" when ByteEnable(2) = '1' else
		Address(15 downto 2) & "11" when ByteEnable(3) = '1' else
		(others => '0');
	
	ReadData <= PreReadData;
	
	Match <= PreMatchReadControlReg or PreMatchWriteControlReg
		  or PreMatchReadPulsePeriodReg or PreMatchWritePulsePeriodReg
		  or PreMatchReadPulseWidthReg or PreMatchWritePulseWidthReg;
	
	WaitRequest <= not (PreReadAckControlReg or PreWriteAckControlReg
		or PreReadAckPulsePeriodReg or PreWriteAckPulsePeriodReg
		or PreReadAckPulseWidthReg or PreWriteAckPulseWidthReg);
	
	PreOrReadDataControlReg <= "000000000000000000000000000000" & PreReadDataControlReg
		when (PreMatchReadControlReg = '1' and PreReadAckControlReg = '1')
		else (others => '0');
	
	PreOrReadDataPulsePeriodReg <= PreReadDataPulsePeriodReg & x"00"
		when (PreMatchReadPulsePeriodReg = '1' and PreReadAckPulsePeriodReg = '1')
		else (others => '0');
	
	PreOrReadDataPulseWidthReg <= PreReadDataPulseWidthReg & x"00"
		when (PreMatchReadPulseWidthReg = '1' and PreReadAckPulseWidthReg = '1')
		else (others => '0');
	
	PreReadData <= PreOrReadDataControlReg
		or PreOrReadDataPulsePeriodReg
		or PreOrReadDataPulseWidthReg;
	
	PreMatchReadControlRegProcess : process (ByteAddress, Read)
	begin
		if (unsigned(ByteAddress) = unsigned(CONTROLREG_ADDRESS)) then
			PreMatchReadControlReg <= Read;
		else
			PreMatchReadControlReg <= '0';
		end if;
	end process;
	
	PreMatchWriteControlRegProcess : process (ByteAddress, Write)
	begin
		if (unsigned(ByteAddress) = unsigned(CONTROLREG_ADDRESS)) then
			PreMatchWriteControlReg <= Write;
		else
			PreMatchWriteControlReg <= '0';
		end if;
	end process;
	WriteDiffControlRegProcess : process (ByteAddress, Write, PreWriteAckControlReg)
	begin
		if (unsigned(ByteAddress) = unsigned(CONTROLREG_ADDRESS)) then
			WriteDiffControlReg <= Write and not PreWriteAckControlReg;
		else
			WriteDiffControlReg <= '0';
		end if;
	end process;
	
	ReadDiffControlRegProcess : process (ByteAddress, Read, PreReadAckControlReg)
	begin
		if (unsigned(ByteAddress) = unsigned(CONTROLREG_ADDRESS)) then
			ReadDiffControlReg <= Read and not PreReadAckControlReg;
		else
			ReadDiffControlReg <= '0';
		end if;
	end process;
	
	SyncDomainControlReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckControlReg <= '0';
			PreWriteAckControlReg <= '0';
			WRegOperation <= CLEARED;
		elsif rising_edge(Clk) then
			PreWriteAckControlReg <= WriteDiffControlReg;
			PreReadAckControlReg <= ReadDiffControlReg;
			if (WriteDiffControlReg = '1') then
				if (ByteEnable(0) = '1') then WRegOperation(1 downto 0) <= WriteData(1 downto 0); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxControlReg : process (
		WRegOperation
	) begin
		PreReadDataControlReg <= (others => '0');
		PreReadDataControlReg(1 downto 0) <= WRegOperation;
	end process;
	
	Operation <= WRegOperation;
	
	PreMatchReadPulsePeriodRegProcess : process (ByteAddress, Read)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEPERIODREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEPERIODREG_ADDRESS) + 3) then
			PreMatchReadPulsePeriodReg <= Read;
		else
			PreMatchReadPulsePeriodReg <= '0';
		end if;
	end process;
	
	PreMatchWritePulsePeriodRegProcess : process (ByteAddress, Write)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEPERIODREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEPERIODREG_ADDRESS) + 3) then
			PreMatchWritePulsePeriodReg <= Write;
		else
			PreMatchWritePulsePeriodReg <= '0';
		end if;
	end process;
	WriteDiffPulsePeriodRegProcess : process (ByteAddress, Write, PreWriteAckPulsePeriodReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEPERIODREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEPERIODREG_ADDRESS) + 3) then
			WriteDiffPulsePeriodReg <= Write and not PreWriteAckPulsePeriodReg;
		else
			WriteDiffPulsePeriodReg <= '0';
		end if;
	end process;
	
	ReadDiffPulsePeriodRegProcess : process (ByteAddress, Read, PreReadAckPulsePeriodReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEPERIODREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEPERIODREG_ADDRESS) + 3) then
			ReadDiffPulsePeriodReg <= Read and not PreReadAckPulsePeriodReg;
		else
			ReadDiffPulsePeriodReg <= '0';
		end if;
	end process;
	
	SyncDomainPulsePeriodReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckPulsePeriodReg <= '0';
			PreWriteAckPulsePeriodReg <= '0';
			WRegPulsePeriodNs <= (others => '0');
		elsif rising_edge(Clk) then
			PreWriteAckPulsePeriodReg <= WriteDiffPulsePeriodReg;
			PreReadAckPulsePeriodReg <= ReadDiffPulsePeriodReg;
			if (WriteDiffPulsePeriodReg = '1') then
				if (ByteEnable(3) = '1') then WRegPulsePeriodNs(23 downto 16) <= WriteData(31 downto 24); end if;
				if (ByteEnable(2) = '1') then WRegPulsePeriodNs(15 downto 8) <= WriteData(23 downto 16); end if;
				if (ByteEnable(1) = '1') then WRegPulsePeriodNs(7 downto 0) <= WriteData(15 downto 8); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxPulsePeriodReg : process (
		WRegPulsePeriodNs
	) begin
		PreReadDataPulsePeriodReg <= (others => '0');
		PreReadDataPulsePeriodReg(31 downto 0) <= WRegPulsePeriodNs;
	end process;
	
	PulsePeriodNs <= WRegPulsePeriodNs;
	
	PreMatchReadPulseWidthRegProcess : process (ByteAddress, Read)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEWIDTHREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEWIDTHREG_ADDRESS) + 3) then
			PreMatchReadPulseWidthReg <= Read;
		else
			PreMatchReadPulseWidthReg <= '0';
		end if;
	end process;
	
	PreMatchWritePulseWidthRegProcess : process (ByteAddress, Write)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEWIDTHREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEWIDTHREG_ADDRESS) + 3) then
			PreMatchWritePulseWidthReg <= Write;
		else
			PreMatchWritePulseWidthReg <= '0';
		end if;
	end process;
	WriteDiffPulseWidthRegProcess : process (ByteAddress, Write, PreWriteAckPulseWidthReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEWIDTHREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEWIDTHREG_ADDRESS) + 3) then
			WriteDiffPulseWidthReg <= Write and not PreWriteAckPulseWidthReg;
		else
			WriteDiffPulseWidthReg <= '0';
		end if;
	end process;
	
	ReadDiffPulseWidthRegProcess : process (ByteAddress, Read, PreReadAckPulseWidthReg)
	begin
		if (unsigned(ByteAddress) >= unsigned(PULSEWIDTHREG_ADDRESS) and
			unsigned(ByteAddress) <= unsigned(PULSEWIDTHREG_ADDRESS) + 3) then
			ReadDiffPulseWidthReg <= Read and not PreReadAckPulseWidthReg;
		else
			ReadDiffPulseWidthReg <= '0';
		end if;
	end process;
	
	SyncDomainPulseWidthReg : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreReadAckPulseWidthReg <= '0';
			PreWriteAckPulseWidthReg <= '0';
			WRegPulseWidthNs <= (others => '0');
		elsif rising_edge(Clk) then
			PreWriteAckPulseWidthReg <= WriteDiffPulseWidthReg;
			PreReadAckPulseWidthReg <= ReadDiffPulseWidthReg;
			if (WriteDiffPulseWidthReg = '1') then
				if (ByteEnable(3) = '1') then WRegPulseWidthNs(23 downto 16) <= WriteData(31 downto 24); end if;
				if (ByteEnable(2) = '1') then WRegPulseWidthNs(15 downto 8) <= WriteData(23 downto 16); end if;
				if (ByteEnable(1) = '1') then WRegPulseWidthNs(7 downto 0) <= WriteData(15 downto 8); end if;
			end if;
		end if;
	end process;
	
	DataOutPreMuxPulseWidthReg : process (
		WRegPulseWidthNs
	) begin
		PreReadDataPulseWidthReg <= (others => '0');
		PreReadDataPulseWidthReg(31 downto 0) <= WRegPulseWidthNs;
	end process;
	
	PulseWidthNs <= WRegPulseWidthNs;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity PulseGeneratorPlainIfcAvalonBusMonitor is
	generic (
		CLOCKS_UNTIL_CYCLE_TIMEOUT : integer := 1023
	);
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Read : in  std_logic;
		Write : in  std_logic;
		Match : in std_logic;
		UnoccupiedAck : out std_logic;
		TimeoutAck : out std_logic
	);
end;

architecture Behavioural of PulseGeneratorPlainIfcAvalonBusMonitor is

	function get_num_bits (arg : natural) return natural is
		variable nbits : natural;
		variable n : natural;
	begin
		n := arg;
		nbits := 1;
		while n > 1 loop
			nbits := nbits + 1;
			n := n / 2;
		end loop;
		return nbits;
	end function;

	constant TimeoutCounterWidth : integer := get_num_bits(CLOCKS_UNTIL_CYCLE_TIMEOUT);
	constant TimeoutCounterLeft : integer := TimeoutCounterWidth - 1;

	signal BusAccessDelay : std_logic;
	signal BusAccess : std_logic;
	signal PreUnoccupiedAck : std_logic;
	signal PreTimeoutAck : std_logic;
	signal TimeoutCounter : unsigned(TimeoutCounterLeft downto 0) := to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);

begin

	BusAccess <= Read or Write;

	BusAccessDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			BusAccessDelay <= '0';
		elsif rising_edge(Clk) then
			BusAccessDelay <= BusAccess;
		end if;
	end process;

	MatchDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreUnoccupiedAck <= '0';
		elsif rising_edge(Clk) then
			PreUnoccupiedAck <= '0';
			if ((BusAccess = '1') and (BusAccessDelay = '1') and (Match = '0')) then
				PreUnoccupiedAck <= not PreUnoccupiedAck;
			end if;
		end if;
	end process;
	
	TimeoutDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreTimeoutAck <= '0';
			TimeoutCounter <= to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);
		elsif rising_edge(Clk) then
			PreTimeoutAck <= '0';
			TimeoutCounter <= to_unsigned(CLOCKS_UNTIL_CYCLE_TIMEOUT, TimeoutCounterWidth);
			if ((BusAccess = '1') and (BusAccessDelay = '1') and (Match = '1')) then
				if (TimeoutCounter = 0) then
					PreTimeoutAck <= not PreTimeoutAck;
				else
					if (PreTimeoutAck = '0') then
						TimeoutCounter <= TimeoutCounter - 1;
					end if;
				end if;
			end if;
		end if;
	end process;

	UnoccupiedAck <= PreUnoccupiedAck;
	TimeoutAck <= PreTimeoutAck;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.PulseGeneratorPlainIfcAvalonPackage.all;
use work.PulseGeneratorPlainIfcUserPackage.all;

entity PulseGeneratorPlainIfcAvalon is
	generic (
		CLOCKS_UNTIL_CYCLE_TIMEOUT : integer := 1023
	);
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		AvalonDown : in T_PulseGeneratorPlainIfcAvalonDown;
		AvalonUp : out T_PulseGeneratorPlainIfcAvalonUp;
		Trace : out T_PulseGeneratorPlainIfcAvalonTrace;
		PulseGeneratorPlainBlkDown : out T_PulseGeneratorPlainIfcPulseGeneratorPlainBlkDown
	);
end;

architecture Behavioural of PulseGeneratorPlainIfcAvalon is

	signal BlockMatch : std_logic;
	signal UnoccupiedAck : std_logic;
	signal TimeoutAck : std_logic;
	
	signal PreAvalonUp : T_PulseGeneratorPlainIfcAvalonUp;
	
	signal PulseGeneratorPlainBlkReadData : std_logic_vector(31 downto 0);
	signal PulseGeneratorPlainBlkWaitRequest : std_logic;
	signal PulseGeneratorPlainBlkMatch : std_logic;

begin

	i_PulseGeneratorPlainIfcAvalonBusMonitor : entity work.PulseGeneratorPlainIfcAvalonBusMonitor
		generic map (
			CLOCKS_UNTIL_CYCLE_TIMEOUT => CLOCKS_UNTIL_CYCLE_TIMEOUT
		)
		port map (
			Clk => Clk,
			Rst => Rst,
			Read => AvalonDown.Read,
			Write => AvalonDown.Write,
			Match => BlockMatch,
			UnoccupiedAck => UnoccupiedAck,
			TimeoutAck => TimeoutAck
		);
	
	i_PulseGeneratorPlainBlk_PulseGeneratorPlainIfcAvalon : entity work.PulseGeneratorPlainBlk_PulseGeneratorPlainIfcAvalon
		port map (
			Clk => Clk,
			Rst => Rst,
			Address => AvalonDown.Address,
			ByteEnable => AvalonDown.ByteEnable,
			Read => AvalonDown.Read,
			ReadData =>  PulseGeneratorPlainBlkReadData,
			Write => AvalonDown.Write,
			WriteData => AvalonDown.WriteData,
			WaitRequest => PulseGeneratorPlainBlkWaitRequest,
			Match => PulseGeneratorPlainBlkMatch,
			Operation => PulseGeneratorPlainBlkDown.Operation,
			PulsePeriodNs => PulseGeneratorPlainBlkDown.PulsePeriodNs,
			PulseWidthNs => PulseGeneratorPlainBlkDown.PulseWidthNs
		);
	
	Trace.AvalonDown <= AvalonDown;
	Trace.AvalonUp <= PreAvalonUp;
	Trace.UnoccupiedAck <= UnoccupiedAck;
	Trace.TimeoutAck <= TimeoutAck;
	
	AvalonUp <= PreAvalonUp;
	
	PreAvalonUp.ReadData <= PulseGeneratorPlainBlkReadData;
	
	PreAvalonUp.WaitRequest <= PulseGeneratorPlainBlkWaitRequest
		and not UnoccupiedAck
		and not TimeoutAck;
	
	BlockMatch <= PulseGeneratorPlainBlkMatch;

end;
